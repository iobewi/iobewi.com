{
  "myactuator": {
    "key": "myactuator",
    "cardTitle": "ROS 2 / ros2_control : MyActuator",
    "cardKicker": "Stabiliser l’interface actionneur dans ROS 2.",
    "cardDescription": "Intégration ros2_control pour piloter des actionneurs MyActuator avec une séparation claire des responsabilités.",
    "cardTags": [
      "Interface stable",
      "Contrôle",
      "Intégration reproductible"
    ],
    "title": "ROS 2 / ros2_control : Intégration MyActuator",
    "modalKicker": "Stabiliser l’interface actionneur dans ROS 2.",
    "lead": "Brique d’intégration ros2_control pour actionneurs MyActuator, conçue pour clarifier l’interface hardware, sécuriser le contrôle et rendre l’intégration traçable.",
    "leftTitle": "Points techniques",
    "leftList": [
      "Gestion de la communication série propriétaire des actionneurs",
      "Respect des interfaces ros2_control (hardware_interface, controller_interface)",
      "Découpage clair : driver bas niveau vs interface ros2_control",
      "Exemples reproductibles + documentation d’intégration"
    ],
    "rightTitle": "Ce que ça valide",
    "rightText": "Validation d’un pattern d’intégration actionneur ROS 2 : interface stable, responsabilités explicites, configuration maîtrisée et mise en œuvre reproductible sur plateforme réelle.",
    "links": [
      {
        "label": "Explorer le projet",
        "url": "https://github.com/ioio2995/myactuator_ros2_control"
      }
    ]
  },
  "witmotion": {
    "key": "witmotion",
    "cardTitle": "ROS 2 : Driver IMU WitMotion",
    "cardKicker": "Fiabiliser l’acquisition IMU série.",
    "cardDescription": "Driver ROS 2 C++ pour capteurs WitMotion avec communication série asynchrone et intégration standard.",
    "cardTags": [
      "Acquisition",
      "Asynchrone",
      "ROS 2 standard"
    ],
    "title": "ROS 2 : Driver IMU WitMotion",
    "modalKicker": "Fiabiliser l’acquisition IMU série.",
    "lead": "Driver ROS 2 en C++ pour capteurs WitMotion, structuré pour une acquisition série robuste et une intégration sans friction dans un graphe ROS 2 standard.",
    "leftTitle": "Points techniques",
    "leftList": [
      "Communication série asynchrone (asio), indépendante de la plateforme",
      "Publication ROS 2 conditionnée aux messages activés (configuration)",
      "Paramétrage : port, débit, fréquence, frame_id",
      "Exemples de lancement + documentation d’intégration"
    ],
    "rightTitle": "Ce que ça valide",
    "rightText": "Validation d’un driver capteur ROS 2 orienté intégration : acquisition stable, configuration claire, publication conforme, et mise en service reproductible.",
    "links": [
      {
        "label": "Explorer le projet",
        "url": "https://github.com/ioio2995/witmotion_ros2"
      }
    ]
  },
  "daly": {
    "key": "daly",
    "cardTitle": "micro-ROS : BMS Daly via ESP32",
    "cardKicker": "Remonter l’énergie dans le graphe ROS 2.",
    "cardDescription": "Supervision batterie Daly dans ROS 2 via ESP32 et micro-ROS pour diagnostic et exploitation.",
    "cardTags": [
      "Énergie",
      "micro-ROS",
      "Supervision"
    ],
    "title": "micro-ROS : Support BMS Daly via ESP32",
    "modalKicker": "Remonter l’énergie dans le graphe ROS 2.",
    "lead": "Support Daly BMS via ESP32 + micro-ROS pour exposer les mesures batterie dans ROS 2 et outiller le diagnostic énergétique d’un système embarqué.",
    "leftTitle": "Fonctionnalités",
    "leftList": [
      "Lecture tension, courant, SoC (télémétrie batterie)",
      "Publication ROS 2 via micro-ROS (nœud embarqué)",
      "Diagnostics / alertes exploitables côté supervision",
      "Socle pour stratégies d’autonomie et de sécurité énergétique"
    ],
    "rightTitle": "Ce que ça valide",
    "rightText": "Validation d’une chaîne microcontrôleur → ROS 2 pour supervision énergétique : acquisition fiable, publication structurée et intégration exploitable par des nœuds de décision/sécurité.",
    "links": [
      {
        "label": "Explorer le projet",
        "url": "https://github.com/ioio2995/uros_DalyBMS"
      }
    ]
  },
  "idf": {
    "key": "idf",
    "cardTitle": "ESP-IDF : Librairie de composants",
    "cardKicker": "Structurer un socle embarqué maintenable.",
    "cardDescription": "Base modulaire pour organiser drivers, bibliothèques, middleware et apps de référence sous ESP-IDF.",
    "cardTags": [
      "Architecture",
      "Réutilisation",
      "CI/validation"
    ],
    "title": "ESP-IDF : Librairie de composants",
    "modalKicker": "Structurer un socle embarqué maintenable.",
    "lead": "Socle de composants ESP-IDF structuré pour réduire la dette technique : découpage en couches, exemples de référence, conventions et outillage d’intégration.",
    "leftTitle": "Organisation",
    "leftList": [
      "Drivers : interfaçage matériel (I2C/SPI/UART, capteurs, actionneurs…)",
      "Librairies : logique indépendante du matériel (helpers, protocoles, outils)",
      "Middleware : assemblage et intégration (services, bus, patterns)",
      "Apps de référence : exemples reproductibles et testables"
    ],
    "rightTitle": "Ce que ça valide",
    "rightText": "Validation d’un modèle de structuration ESP-IDF orienté durée : composants versionnés, intégration reproductible, documentation normative, et base exploitable par une équipe sur le long terme.",
    "links": [
      {
        "label": "Explorer le projet",
        "url": "https://github.com/iobewi/iobewi-idf-components"
      }
    ]
  },
  "icf": {
    "key": "icf",
    "cardTitle": "ICF : Interactions tangibles",
    "cardKicker": "Relier un objet physique à une action embarquée.",
    "cardDescription": "Format + outillage NFC/RFID pour déclencher des actions embarquées (ex : audio HLS) avec approche reproductible.",
    "cardTags": [
      "NFC/RFID",
      "Format",
      "Chaîne embarquée"
    ],
    "title": "ICF : Interactions tangibles & déclenchement physique",
    "modalKicker": "Relier un objet physique à une action embarquée.",
    "lead": "Format et outillage NFC/RFID (TLV compact + mécanisme d’authenticité) pour déclencher des comportements embarqués. Exploration orientée produit : contraintes réelles, intégration et reproductibilité.",
    "leftTitle": "Points techniques",
    "leftList": [
      "Format TLV compact + mécanisme d’authenticité (signature)",
      "CLI + bibliothèque Python réutilisable (génération/validation d’artefacts)",
      "Chaîne embarquée associée (ESP-IDF) : lecture NFC + déclenchement applicatif",
      "Exemple concret : lecteur HLS M3U8 (pipeline streaming)"
    ],
    "rightTitle": "Ce que ça valide",
    "rightText": "Validation d’un pattern “phygital” : artefact physique → donnée vérifiable → comportement embarqué. Découpage clair (format/outillage/runtime) et chaîne d’intégration documentée.",
    "links": [
      {
        "label": "Explorer le projet ICF",
        "url": "https://github.com/iobewi/icf"
      },
      {
        "label": "Explorer iobewi_apps_hls_player",
        "url": "https://github.com/iobewi/iobewi-idf-components/tree/iobewi_driver_max98357a/components/iobewi_apps_hls_player"
      }
    ]
  }
}